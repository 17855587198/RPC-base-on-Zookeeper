# 分布式缓存服务使用指南

## 功能概述

在原有的RPC框架基础上，新增了分布式缓存服务，提供高性能的内存缓存功能，支持：
- 键值对存储与获取
- 过期时间管理
- 批量操作
- 缓存统计
- 自动清理过期键

## 服务接口

### 1. 设置缓存 (Set)
```proto
message CacheSetRequest {
    bytes key = 1;               // 缓存键
    bytes value = 2;             // 缓存值
    int32 expire_seconds = 3;    // 过期时间（秒），0表示永不过期
}
```

### 2. 获取缓存 (Get)
```proto
message CacheGetRequest {
    bytes key = 1;               // 缓存键
}

message CacheGetResponse {
    ResultCode result = 1;       // 操作结果
    bytes value = 2;             // 缓存值
    bool exists = 3;             // 键是否存在
    int64 expire_time = 4;       // 过期时间戳
}
```

### 3. 批量获取 (BatchGet)
```proto
message CacheBatchGetRequest {
    repeated bytes keys = 1;     // 多个缓存键
}

message CacheBatchGetResponse {
    ResultCode result = 1;
    repeated CacheItem items = 2; // 批量结果
}
```

### 4. 删除缓存 (Delete)
```proto
message CacheDeleteRequest {
    bytes key = 1;               // 要删除的键
}
```

### 5. 检查存在性 (Exists)
```proto
message CacheExistsRequest {
    bytes key = 1;               // 检查的键
}

message CacheExistsResponse {
    ResultCode result = 1;
    bool exists = 2;             // 是否存在
}
```

### 6. 获取统计信息 (GetStats)
```proto
message CacheStatsResponse {
    ResultCode result = 1;
    int64 total_keys = 2;        // 总键数
    int64 memory_usage = 3;      // 内存使用量
    int64 hit_count = 4;         // 命中次数
    int64 miss_count = 5;        // 未命中次数
    double hit_rate = 6;         // 命中率
}
```

## 使用示例

### C++客户端使用

```cpp
#include "Zrpcapplication.h"
#include "user.pb.h"

int main() {
    // 初始化RPC框架
    ZrpcApplication::Init(argc, argv);
    
    // 创建缓存服务客户端
    ZrpcChannel* channel = new ZrpcChannel(false);
    Kuser::CacheServiceRpc_Stub stub(channel);
    
    // 1. 设置缓存
    Kuser::CacheSetRequest set_req;
    set_req.set_key("user:1001");
    set_req.set_value("{\"name\":\"张三\",\"age\":25}");
    set_req.set_expire_seconds(300);  // 5分钟过期
    
    Kuser::ResultCode set_resp;
    stub.Set(nullptr, &set_req, &set_resp, nullptr);
    
    // 2. 获取缓存
    Kuser::CacheGetRequest get_req;
    get_req.set_key("user:1001");
    
    Kuser::CacheGetResponse get_resp;
    stub.Get(nullptr, &get_req, &get_resp, nullptr);
    
    if (get_resp.exists()) {
        std::cout << "缓存值: " << get_resp.value() << std::endl;
    }
    
    delete channel;
    return 0;
}
```

## 应用场景

### 1. 用户会话管理
```cpp
// 用户登录后，将会话信息存入缓存
void cache_user_session(const std::string& username, const std::string& session_token) {
    Kuser::CacheSetRequest request;
    request.set_key("session:" + username);
    request.set_value(session_token);
    request.set_expire_seconds(1800);  // 30分钟会话
    
    // 调用缓存服务...
}

// 验证用户会话
bool validate_user_session(const std::string& username) {
    Kuser::CacheGetRequest request;
    request.set_key("session:" + username);
    
    Kuser::CacheGetResponse response;
    // 调用缓存服务...
    
    return response.exists();
}
```

### 2. 数据缓存
```cpp
// 缓存数据库查询结果
void cache_user_profile(int user_id, const std::string& profile_json) {
    Kuser::CacheSetRequest request;
    request.set_key("profile:" + std::to_string(user_id));
    request.set_value(profile_json);
    request.set_expire_seconds(600);  // 10分钟缓存
    
    // 调用缓存服务...
}
```

### 3. 计数器
```cpp
// 缓存API调用次数
void increment_api_counter(const std::string& api_name) {
    std::string key = "counter:" + api_name;
    
    // 先获取当前值
    Kuser::CacheGetRequest get_req;
    get_req.set_key(key);
    
    Kuser::CacheGetResponse get_resp;
    // 调用获取...
    
    int count = 1;
    if (get_resp.exists()) {
        count = std::stoi(get_resp.value()) + 1;
    }
    
    // 更新计数
    Kuser::CacheSetRequest set_req;
    set_req.set_key(key);
    set_req.set_value(std::to_string(count));
    set_req.set_expire_seconds(86400);  // 24小时
    
    // 调用设置...
}
```

## 性能特性

### 1. 高性能内存存储
- 基于C++ std::unordered_map实现
- 读写锁支持多读单写
- 内存级别的访问速度

### 2. 自动过期清理
- 后台定时清理过期键
- 避免内存泄漏
- 可配置清理间隔

### 3. 统计监控
- 实时命中率统计
- 内存使用量监控
- 操作计数跟踪

### 4. 线程安全
- 使用std::shared_mutex保证线程安全
- 支持高并发读操作
- 写操作互斥保护

## 编译说明

### 1. 更新protobuf文件
```bash
cd example
protoc --cpp_out=. user.proto
```

### 2. 编译服务端
```bash
cd callee
g++ -o cache_server Kserver.cc CacheService.cc ../user.pb.cc \
    -I../../src/include -L../../build/src -lZrpc_core \
    -lprotobuf -lzookeeper_mt -lglog -lpthread
```

### 3. 编译客户端
```bash
cd caller
g++ -o cache_test cache_client_test.cc ../user.pb.cc \
    -I../../src/include -L../../build/src -lZrpc_core \
    -lprotobuf -lzookeeper_mt -lglog -lpthread
```

## 配置示例

### test.conf
```ini
# RPC服务配置
rpcserver_ip=127.0.0.1
rpcserver_port=8000

# ZooKeeper配置
zookeeper_ip=127.0.0.1
zookeeper_port=2181
```

## 运行测试

### 1. 启动ZooKeeper
```bash
zkServer.sh start
```

### 2. 启动RPC服务端
```bash
cd callee
./cache_server -i test.conf
```

### 3. 运行缓存测试
```bash
cd caller
./cache_test -i test.conf
```

## 扩展建议

### 1. 持久化支持
- 添加定期快照功能
- 支持从快照恢复
- 实现WAL日志

### 2. 分布式集群
- 一致性哈希分片
- 主从复制
- 故障转移

### 3. 更多数据类型
- List、Set、Hash类型
- 原子操作支持
- Lua脚本执行

这个分布式缓存服务为您的RPC框架增加了企业级的缓存能力，大大提升了系统的性能和可扩展性！
